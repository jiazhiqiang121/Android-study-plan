设计模式

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

一.策略模式
笔记：
1.把问题归零 
2.找到应用中需要修改代码的地方
3.在于随时想到系统以后可能需要的变化以及应付变化的原则
4.把会变化的部分取出来并封装起来，好让其他部分不会收到影响。
5.分开变化和不会变化的部分
6.在实现类构造方法中动态初始化行为和属性
7.动态改变行为需要在super类设置一个公共的setter方法
8.建立弹性的设计，可以维护可以应付改变
9.良好的设计必须具备可复用，可扩充，可维护三个特性
10.大多数的模式都允许系统局部改变独立于其他部分
11.我们常把系统中会变化的部分抽出来封装
------------------------------------------------------------
基础
抽象.封装.继承.多态
设计原则
1.封装变化：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
2.针对接口编程，而不是针对实现编程
3.多用组合，少用继承
正式定义
策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

二.观察者模式
笔记：
1.在观察者模式中，会改变的是主题的状态，以及观察者的数目和类型。用这个模式，你可以改变依赖与主题状态的对象，却不必改变主题。
2.主题和观察者都使用接口：观察者利用主题的接口向主题注册，而主题利用观察者接口通知观察者。这样让两者之间运作正常，又同时具有
松耦合的优点。
3.观察者模式利用‘组合’将许多观察者组合进主题中。对象之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式产生的。
------------------------------------------------------------
正式定义
观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

设计原则
为了交互对象之间的松耦合而设计

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

三.装饰者模式
开放关闭原则
设计原则
类应该对扩展开放，对修改关闭

笔记：
1.装饰者和被装饰者对象有相同的超类型
2.你可以用一个或多个装饰者包装一个对象
3.既然装饰者和被装饰者对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它。
4.装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。
5.对象可以在任何时候被装饰，所以可以在运行时动态地，不限量地用你喜欢的装饰者来装饰对象。
6.继承属于扩展形式之一，但不见得达到弹性设计的最佳方式。
7.在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码。
8.组合和委托可用于在运行时动态地加上新的行动
9.除了继承，装饰者模式也可以让我们扩展行为。
10.装饰者模式意味着一群装饰者类，这些类用来包装具体组件。
11.装饰者类反映出被装饰的组件类型
12.装饰者可以在被装饰者的行为前面或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。
13.你可以用无数个装饰者包装一个组件。
14.装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。
15.装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。

正式定义
装饰者模式动态地将责任附加在对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

四.工厂模式





